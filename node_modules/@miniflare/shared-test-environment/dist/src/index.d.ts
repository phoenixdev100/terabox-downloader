import { Awaitable } from '@miniflare/shared';
import { BindingsPlugin } from '@miniflare/core';
import { CachePlugin } from '@miniflare/cache';
import { Context } from '@miniflare/shared';
import { CorePlugin } from '@miniflare/core';
import { D1Plugin } from '@miniflare/d1';
import { DurableObject } from '@miniflare/durable-objects';
import { DurableObjectId } from '@miniflare/durable-objects';
import { DurableObjectsPlugin } from '@miniflare/durable-objects';
import { DurableObjectState } from '@miniflare/durable-objects';
import { DurableObjectStorage } from '@miniflare/durable-objects';
import { FetchEvent } from '@miniflare/core';
import { HTMLRewriterPlugin } from '@miniflare/html-rewriter';
import { KVPlugin } from '@miniflare/kv';
import { kWaitUntil } from '@miniflare/core';
import { MemoryStorage } from '@miniflare/storage-memory';
import { MiniflareCore } from '@miniflare/core';
import { MiniflareCoreContext } from '@miniflare/core';
import { MiniflareCoreOptions } from '@miniflare/core';
import { MockAgent } from 'undici';
import { QueuesPlugin } from '@miniflare/queues';
import { R2Plugin } from '@miniflare/r2';
import { ScheduledEvent } from '@miniflare/core';
import { SitesPlugin } from '@miniflare/sites';
import { Storage } from '@miniflare/shared';
import { StorageFactory } from '@miniflare/shared';
import { WebSocketPlugin } from '@miniflare/web-sockets';

export declare function createMiniflareEnvironment(ctx: Pick<MiniflareCoreContext, "storageFactory" | "scriptRunner" | "queueBroker">, options: MiniflareCoreOptions<typeof PLUGINS>, globalOverrides?: Context): Promise<[mf: MiniflareCore<typeof PLUGINS>, globals: Context]>;

export declare class ExecutionContext {
    [kWaitUntil]: Promise<unknown>[];
    passThroughOnException(): void;
    waitUntil(promise: Promise<any>): void;
}

export declare interface MiniflareEnvironmentUtilities {
    getMiniflareBindings<Bindings = Context>(): Bindings;
    getMiniflareDurableObjectStorage(id: DurableObjectId): Promise<DurableObjectStorage>;
    getMiniflareDurableObjectState(id: DurableObjectId): Promise<DurableObjectState>;
    getMiniflareDurableObjectInstance(id: DurableObjectId): Promise<DurableObject>;
    runWithMiniflareDurableObjectGates<T>(state: DurableObjectState, closure: () => Awaitable<T>): Promise<T>;
    getMiniflareFetchMock(): MockAgent;
    getMiniflareWaitUntil<WaitUntil extends any[] = unknown[]>(event: FetchEvent | ScheduledEvent | ExecutionContext): Promise<WaitUntil>;
    flushMiniflareDurableObjectAlarms(ids: DurableObjectId[]): Promise<void>;
    getMiniflareDurableObjectIds(namespace: string): Promise<DurableObjectId[]>;
}

export declare const PLUGINS: {
    CorePlugin: typeof CorePlugin;
    KVPlugin: typeof KVPlugin;
    D1Plugin: typeof D1Plugin;
    R2Plugin: typeof R2Plugin;
    DurableObjectsPlugin: typeof DurableObjectsPlugin;
    CachePlugin: typeof CachePlugin;
    SitesPlugin: typeof SitesPlugin;
    QueuesPlugin: typeof QueuesPlugin;
    HTMLRewriterPlugin: typeof HTMLRewriterPlugin;
    WebSocketPlugin: typeof WebSocketPlugin;
    BindingsPlugin: typeof BindingsPlugin;
};

export declare class StackedMemoryStorage extends MemoryStorage {
    private readonly stack;
    private readonly transactionStack;
    push(): void;
    pop(): void;
}

export declare class StackedMemoryStorageFactory implements StorageFactory {
    private readonly storages;
    storage(namespace: string, persist?: boolean | string): Storage;
    push(): void;
    pop(): void;
}

export { }
