var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// packages/shared-test-environment/src/index.ts
__export(exports, {
  ExecutionContext: () => ExecutionContext,
  PLUGINS: () => PLUGINS,
  StackedMemoryStorage: () => StackedMemoryStorage,
  StackedMemoryStorageFactory: () => StackedMemoryStorageFactory,
  createMiniflareEnvironment: () => createMiniflareEnvironment
});
var import_core3 = __toModule(require("@miniflare/core"));
var import_shared = __toModule(require("@miniflare/shared"));

// packages/shared-test-environment/src/globals.ts
var import_core = __toModule(require("@miniflare/core"));
var import_durable_objects = __toModule(require("@miniflare/durable-objects"));
var ExecutionContext = class {
  [import_core.kWaitUntil] = [];
  passThroughOnException() {
  }
  waitUntil(promise) {
    this[import_core.kWaitUntil].push(promise);
  }
};
async function createMiniflareEnvironmentUtilities(mf, fetchMock) {
  const bindings = await mf.getBindings();
  return {
    getMiniflareBindings() {
      return bindings;
    },
    async getMiniflareDurableObjectStorage(id) {
      const plugin = (await mf.getPlugins()).DurableObjectsPlugin;
      const factory = mf.getPluginStorage("DurableObjectsPlugin");
      return plugin.getStorage(factory, id);
    },
    async getMiniflareDurableObjectState(id) {
      const plugin = (await mf.getPlugins()).DurableObjectsPlugin;
      const factory = mf.getPluginStorage("DurableObjectsPlugin");
      const storage = plugin.getStorage(factory, id);
      return new import_durable_objects.DurableObjectState(id, storage);
    },
    async getMiniflareDurableObjectInstance(id) {
      const plugin = (await mf.getPlugins()).DurableObjectsPlugin;
      const factory = mf.getPluginStorage("DurableObjectsPlugin");
      return await plugin.getInstance(factory, id);
    },
    runWithMiniflareDurableObjectGates(state, closure) {
      return state[import_durable_objects._kRunWithGates](closure);
    },
    getMiniflareFetchMock() {
      return fetchMock;
    },
    getMiniflareWaitUntil(event) {
      return Promise.all(event[import_core.kWaitUntil]);
    },
    async flushMiniflareDurableObjectAlarms(ids) {
      const plugin = (await mf.getPlugins()).DurableObjectsPlugin;
      const factory = mf.getPluginStorage("DurableObjectsPlugin");
      return plugin.flushAlarms(factory, ids);
    },
    async getMiniflareDurableObjectIds(namespace) {
      const plugin = (await mf.getPlugins()).DurableObjectsPlugin;
      const factory = mf.getPluginStorage("DurableObjectsPlugin");
      return plugin.getObjects(factory, namespace);
    }
  };
}

// packages/shared-test-environment/src/plugins.ts
var import_cache = __toModule(require("@miniflare/cache"));
var import_core2 = __toModule(require("@miniflare/core"));
var import_d1 = __toModule(require("@miniflare/d1"));
var import_durable_objects2 = __toModule(require("@miniflare/durable-objects"));
var import_html_rewriter = __toModule(require("@miniflare/html-rewriter"));
var import_kv = __toModule(require("@miniflare/kv"));
var import_queues = __toModule(require("@miniflare/queues"));
var import_r2 = __toModule(require("@miniflare/r2"));
var import_sites = __toModule(require("@miniflare/sites"));
var import_web_sockets = __toModule(require("@miniflare/web-sockets"));
var PLUGINS = {
  CorePlugin: import_core2.CorePlugin,
  KVPlugin: import_kv.KVPlugin,
  D1Plugin: import_d1.D1Plugin,
  R2Plugin: import_r2.R2Plugin,
  DurableObjectsPlugin: import_durable_objects2.DurableObjectsPlugin,
  CachePlugin: import_cache.CachePlugin,
  SitesPlugin: import_sites.SitesPlugin,
  QueuesPlugin: import_queues.QueuesPlugin,
  HTMLRewriterPlugin: import_html_rewriter.HTMLRewriterPlugin,
  WebSocketPlugin: import_web_sockets.WebSocketPlugin,
  BindingsPlugin: import_core2.BindingsPlugin
};

// packages/shared-test-environment/src/storage.ts
var import_assert = __toModule(require("assert"));
var import_storage_memory = __toModule(require("@miniflare/storage-memory"));
var StackedMemoryStorage = class extends import_storage_memory.MemoryStorage {
  stack = [];
  transactionStack = [];
  push() {
    this.stack.push(this.map);
    this.map = new Map(this.map);
    if (this.sqliteDB) {
      const transactionName = `STACK_${this.transactionStack.length + 1}`;
      this.transactionStack.push(transactionName);
      this.sqliteDB.exec(`SAVEPOINT ${transactionName}`);
    }
  }
  pop() {
    this.map = this.stack.pop() ?? new Map();
    if (this.sqliteDB) {
      const transactionToRollback = this.transactionStack.pop();
      if (transactionToRollback) {
        this.sqliteDB.exec(`ROLLBACK TO ${transactionToRollback}`);
        this.sqliteDB.exec(`RELEASE ${transactionToRollback}`);
      }
    }
  }
};
var StackedMemoryStorageFactory = class {
  storages = new Map();
  storage(namespace, persist) {
    (0, import_assert.default)(!persist);
    let storage = this.storages.get(namespace);
    if (storage)
      return storage;
    this.storages.set(namespace, storage = new StackedMemoryStorage());
    return storage;
  }
  push() {
    for (const storage of this.storages.values())
      storage.push();
  }
  pop() {
    for (const storage of this.storages.values())
      storage.pop();
  }
};

// packages/shared-test-environment/src/index.ts
var log = new import_shared.NoOpLog();
async function createMiniflareEnvironment(ctx, options, globalOverrides) {
  const fetchMock = (0, import_core3.createFetchMock)();
  const mf = new import_core3.MiniflareCore(PLUGINS, {
    log,
    ...ctx,
    scriptRunForModuleExports: true
  }, {
    wranglerConfigPath: true,
    packagePath: true,
    envPathDefaultFallback: true,
    ...options,
    globals: {
      ...options?.globals,
      ...globalOverrides
    },
    watch: false,
    kvPersist: false,
    d1Persist: false,
    r2Persist: false,
    cachePersist: false,
    durableObjectsPersist: false,
    globalAsyncIO: true,
    globalTimers: true,
    globalRandom: true,
    actualTime: true,
    fetchMock
  });
  const mfGlobalScope = await mf.getGlobalScope();
  mfGlobalScope.global = global;
  mfGlobalScope.self = global;
  const mfUtilities = await createMiniflareEnvironmentUtilities(mf, fetchMock);
  Object.assign(mfGlobalScope, mfUtilities);
  return [mf, mfGlobalScope];
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ExecutionContext,
  PLUGINS,
  StackedMemoryStorage,
  StackedMemoryStorageFactory,
  createMiniflareEnvironment
});
//# sourceMappingURL=index.js.map
