var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// packages/jest-environment-miniflare/src/index.ts
__export(exports, {
  default: () => MiniflareEnvironment
});
var import_vm = __toModule(require("vm"));
var import_fake_timers = __toModule(require("@jest/fake-timers"));
var import_queues = __toModule(require("@miniflare/queues"));
var import_runner_vm = __toModule(require("@miniflare/runner-vm"));
var import_shared_test_environment = __toModule(require("@miniflare/shared-test-environment"));
var import_jest_mock = __toModule(require("jest-mock"));
var import_jest_util = __toModule(require("jest-util"));
var MiniflareEnvironment = class {
  config;
  context;
  fakeTimers;
  fakeTimersModern;
  global;
  moduleMocker;
  customExportConditions = ["worker", "browser"];
  storageFactory = new import_shared_test_environment.StackedMemoryStorageFactory();
  scriptRunner;
  queueBroker = new import_queues.QueueBroker();
  mf;
  constructor(config, _context) {
    if ("projectConfig" in config)
      config = config.projectConfig;
    this.config = config;
    this.context = import_vm.default.createContext({});
    (0, import_runner_vm.defineHasInstances)(this.context);
    this.scriptRunner = new import_runner_vm.VMScriptRunner(this.context);
    const global = this.global = import_vm.default.runInContext("this", this.context);
    global.global = global;
    global.self = global;
    global.clearInterval = clearInterval;
    global.clearTimeout = clearTimeout;
    global.setInterval = setInterval;
    global.setTimeout = setTimeout;
    global.Buffer = Buffer;
    (0, import_jest_util.installCommonGlobals)(global, this.config.globals);
    if ("customExportConditions" in this.config.testEnvironmentOptions) {
      const { customExportConditions } = this.config.testEnvironmentOptions;
      if (Array.isArray(customExportConditions) && customExportConditions.every((item) => typeof item === "string")) {
        this.customExportConditions = customExportConditions;
      } else {
        throw new Error("Custom export conditions specified but they are not an array of strings");
      }
    }
    this.moduleMocker = new import_jest_mock.ModuleMocker(global);
    const timerIdToRef = (id) => ({
      id,
      ref() {
        return this;
      },
      unref() {
        return this;
      }
    });
    const timerRefToId = (timer) => timer && timer.id || void 0;
    this.fakeTimers = new import_fake_timers.LegacyFakeTimers({
      config: this.config,
      global,
      moduleMocker: this.moduleMocker,
      timerConfig: { idToRef: timerIdToRef, refToId: timerRefToId }
    });
    this.fakeTimersModern = new import_fake_timers.ModernFakeTimers({
      config: this.config,
      global
    });
  }
  async setup() {
    const global = this.global;
    const [mf, mfGlobalScope] = await (0, import_shared_test_environment.createMiniflareEnvironment)({
      storageFactory: this.storageFactory,
      scriptRunner: this.scriptRunner,
      queueBroker: this.queueBroker
    }, this.config.testEnvironmentOptions, {
      ExecutionContext: import_shared_test_environment.ExecutionContext,
      console: global.console,
      setTimeout: global.setTimeout,
      setInterval: global.setInterval,
      clearTimeout: global.clearTimeout,
      clearInterval: global.clearInterval
    });
    this.mf = mf;
    Object.assign(global, mfGlobalScope);
  }
  async teardown() {
    await this.mf?.dispose();
    this.fakeTimers?.dispose();
    this.fakeTimersModern?.dispose();
    this.context = null;
    this.fakeTimers = null;
    this.fakeTimersModern = null;
  }
  exportConditions() {
    return this.customExportConditions;
  }
  getVmContext() {
    return this.context;
  }
  handleTestEvent(event, _state) {
    if (event.name === "run_describe_start" || event.name === "test_start") {
      this.storageFactory.push();
    }
    if (event.name === "run_describe_finish" || event.name === "test_done") {
      this.storageFactory.pop();
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
//# sourceMappingURL=index.js.map
